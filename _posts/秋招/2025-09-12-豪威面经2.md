---
layout: post
title: "豪威面经2"
date: 2025-09-12
category: 秋招
---

# 豪威面经

- [豪威面经](#豪威面经)
  - [拷打](#拷打)
  - [回答](#回答)
    - [问题1：说说为什么做AWB](#问题1说说为什么做awb)
    - [问题2：数组中有了解过new/ delte吗？ 他和普通数组创建int a\[n\]有什么本质区别？](#问题2数组中有了解过new-delte吗-他和普通数组创建int-an有什么本质区别)
    - [问题3：讲一下内存泄漏和野指针的区别](#问题3讲一下内存泄漏和野指针的区别)
    - [问题4：讲一下智能指针](#问题4讲一下智能指针)


> 来自另一个秋招朋友的面试经历

## 拷打

1. 先进性1分钟的自我介绍
2. 深挖研究生期间的两个项目
   1. 项目背景
   2. 担任角色
   3. 实现平台，落地？
   4. 深挖技术难点、细节、难点（结合ISP问）
   5. 精度效果和什么benchmark比的？
3. ISP相关问题（实习经历）
   1. 实习期间是自己实现的每个模块还是调用的现成的？
   2. 说说为什么做AWB
   3. 你实现的AWB用的是什么算法？是基于全局统计的吗？
   4. 有调研过其他AWB算法吗？目前这个领域在解决什么难点？
   5. CMOS成像中噪声来源是什么？
   6. RAW域去噪有了解吗？
   7. GAMMA校正是为什么？
   8. 有了解过HDR模块吗？有自己实现吗？
   9. 3A算法中其他两个有了解吗？
4.  编程语言
    1.  项目中一般用什么编程语言
    2.  用C做过什么项目？
    3.  python如何调用C？
    4.  C++指针传参和普通变量的传参有什么区别？
        - 为什么会有这个区别（地址和值传递的区别） 
    5. 数组中有了解过new/ delte吗？ 他和普通数组创建int a[n]有什么本质区别？
5. 企业文化
   1. 对我们（垃圾，开玩笑）公司/部门有什么了解吗？
6. 反问环节
   > 可千万别问薪资和加班什么的东西啊~  
   问一些技术上和发展上的问题

## 回答
### 问题1：说说为什么做AWB

面试官您好。

我们之所以要做AWB（自动白平衡），其核心目的简单来说，就是为了消除不同光源带来的“偏色”问题，还原物体本来的色彩。

具体来说，主要有两个原因：

第一，是物理原因:
不同色温下的光源颜色也是不同的，随着色温的升高光源的颜色会从黄到蓝变化

第二，是感知差异：
我们的大脑有一个非常厉害的功能叫**“色彩恒常性”**。无论是在日光下还是在黄色灯光下，我们看到一张白纸，都会自动感知它是“白色”的。但相机传感器是个“诚实”的记录设备，在黄色灯光下，它接收到的反射光就是黄色的，所以会把白纸拍成黄色。

因此，AWB算法的作用，就是模仿人眼的这种“色彩恒ter恒常性”能力。

它的工作流程可以概括为两步：

估算光源： AWB算法会分析当前图像的色彩统计信息，来判断当前场景的光源大概是什么颜色（比如是偏黄还是偏蓝）。

进行补偿： 在估算出光源的颜色后，它会计算出一个补偿性的增益值，分别施加在图像的R、G、B三个通道上，把由光源带来的色偏给“拉”回来。

最终的目标就是：让图像中的白色物体，无论在什么光源下，都能被准确地还原成中性的白色。 一旦白色被校准了，画面中的其他所有颜色也就自然而然地恢复了它们的真实面貌。


### 问题2：数组中有了解过new/ delte吗？ 他和普通数组创建int a[n]有什么本质区别？
特性	int a[n]; (普通数组创建)	int* p = new int[n]; (new创建)
内存区域	栈 (Stack)	堆 (Heap / Free Store)
生命周期	自动管理。数组的生命周期与它所在的作用域（如函数体）绑定，作用域结束时，内存自动释放，无需程序员干预。	手动管理。通过new分配的内存会一直存在，直到程序员手动调用delete[]来释放它。如果忘记delete[]，就会造成内存泄漏。
大小限制	栈空间通常较小且固定（一般为几MB），不适合创建非常大的数组，否则可能导致栈溢出 (Stack Overflow)。	堆空间是程序可用的主要内存区域，非常大（GB级别），可以用来创建非常大或大小不确定的数组。
灵活性	在C++标准中，数组大小n必须是在编译时就确定的常量。	数组大小n可以在程序运行时动态确定，比如根据用户的输入来决定数组大小。
返回值	a是数组名，直接使用。	  
释放方式	无需手动释放。	必须使用与new[]配对的delete[]来释放，如果只用delete会导致未定义行为。

### 问题3：讲一下内存泄漏和野指针的区别

内存泄漏：
- 你用 new 在堆上申请了一块内存，但随后丢失了所有指向这块内存的指针。
- 成因： 最常见的就是 new 和 delete / new[] 和 delete[] 没有配对使用。
  
野指针
- 指针指向的内存已经被释放，它指向一个未知的、不合法的内存区域。

### 问题4：讲一下智能指针

智能指针是C++中一个模拟指针行为的对象，它最核心的作用是实现了内存的**自动化管理**，从而从根本上解决了传统裸指针（raw pointer）带来的**内存泄漏和野指针**等问题。

它的实现原理是利用了C++的 RAII (Resource Acquisition Is Initialization) 思想，即在对象构造时获取资源（分配内存），在对象析构时释放资源（释放内存）。

C++11标准库里主要有三种智能指针：

std::unique_ptr (独占指针):
它实现独占式所有权。同一时间内，**只有一个unique_ptr可以指向一个给定的对象**。当这个unique_ptr被销毁时（比如离开作用域），它所指向的对象也会被自动删除。它无法被复制，但可以被移动（std::move），用以转移所有权。

std::shared_ptr (共享指针):
它实现共享式所有权。**多个shared_ptr可以指向同一个对象**。**内部通过一个引用计数器**来跟踪有多少个shared_ptr共同指向该对象。每当有一个新的shared_ptr指向它，计数器加一；每当有一个shared_ptr被销毁，计数器减一。当计数器归零时，对象被自动删除。

std::weak_ptr (弱指针):
它是一种非拥有型的智能指针，用于监视一个由shared_ptr管理的对象，但不会增加其引用计数。它最大的作用是解决shared_ptr可能带来的循环引用问题，从而避免内存泄漏。它不能直接访问对象，需要先转换（lock）成一个shared_ptr。

**总结来说，**在现代C++编程中，应该优先使用智能指针来管理动态分配的内存，以保证代码的异常安全和简洁性。