---
layout: post
title: "C++"
date: 2025-09-17
category: 秋招
---

# C++
- [C++](#c)
  - [一、基础知识](#一基础知识)
  - [二、面向对象](#二面向对象)
    - [1、多态](#1多态)

> 主要搜集自AI+ 各种秋招友分享的面试题

## 一、基础知识
1、 const关键字

这个修饰符是为了告诉编译器修饰的东西是**只读**的

**修饰变量**
表示定义后就不能修改了！

**修饰指针**
这个需要稍微记一下是修饰的指针还是指向的内容
``` C++
   // 常量指针
   int a = 10;
   int b = 20;
   const int* p1 = &a; 
   // *p1 = 5;      // 错误！不能通过p1修改a的值
   p1 = &b;       // 正确！p1可以指向其他地方
```

``` C++
   // 指针常量
   int a = 10;
   int b = 20;
   int* const p2 = &a;
   *p2 = 5;       // 正确！可以通过p2修改a的值
   // p2 = &b;      // 错误！p2不能再指向b
```

**修饰成员函数**
放在成员函数括号后面，表示这个函数不会修改类的任何成员变量
> 注意他的一个内部机制是修饰的 this 指针，所以就导致了传进来的所有成员函数都是const
```C++
   class MyClass {
      int value;
   public:
      int getValue() const { // 常成员函数
         // value = 10; // 错误！不能修改成员变量
         return value;
      }
   };
```

## 二、面向对象
### 1、多态
多态的一个主要作用就是，可以让我们将派生类可以当做基类来统一处理

三个条件：
1. 继承：存在共有继承
2. 虚函数：基类函数通过virtua修饰，子类通过override
3. 基类指针和应用：使用时

 **底层实现原理：虚函数表**
> 可以看这个链接：[虚函数表](https://zhuanlan.zhihu.com/p/75172640)

多态的内部机制就是通过虚函数表来完成的。每个声明或继承了虚函数的类，都会维护一个自己专属的虚函数表。

这个表本质上是一个函数指针数组，它的每个元素都是一个指向虚函数的指针，而不会指向普通的成员函数。

当我们创建一个派生类的对象，并用一个基类的指针指向它时（例如 Base* ptr = new Derived();），在这个派生类对象的内存布局中，其虚函数指针（vptr）就会指向派生类自己的虚函数表。这样，当我们通过这个基类指针调用虚函数时（例如 ptr->virtual_func();），程序就能在运行时找到并执行派生类中重写的版本。

**总结：**

封装、继承、多态是面向对象设计的三个特征，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。

