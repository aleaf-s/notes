---
layout: post
title: "C++"
date: 2025-09-17
category: 秋招
---

# C++
- [C++](#c)
  - [一、基础知识](#一基础知识)
  - [二、面向对象](#二面向对象)
    - [1、多态](#1多态)
    - [2、虚析构函数](#2虚析构函数)

> 主要搜集自AI+ 各种秋招友分享的面试题

## 一、基础知识
**1、 const关键字**

这个修饰符是为了告诉编译器修饰的东西是**只读**的

**修饰变量**
表示定义后就不能修改了！

**修饰指针**
这个需要稍微记一下是修饰的指针还是指向的内容
``` C++
   // 常量指针
   int a = 10;
   int b = 20;
   const int* p1 = &a; 
   // *p1 = 5;      // 错误！不能通过p1修改a的值
   p1 = &b;       // 正确！p1可以指向其他地方
```

``` C++
   // 指针常量
   int a = 10;
   int b = 20;
   int* const p2 = &a;
   *p2 = 5;       // 正确！可以通过p2修改a的值
   // p2 = &b;      // 错误！p2不能再指向b
```

**修饰成员函数**
放在成员函数括号后面，表示这个函数不会修改类的任何成员变量
> 注意他的一个内部机制是修饰的 this 指针，所以就导致了传进来的所有成员函数都是const
```C++
   class MyClass {
      int value;
   public:
      int getValue() const { // 常成员函数
         // value = 10; // 错误！不能修改成员变量
         return value;
      }
   };
```

**2、static**
static 关键字用于改变变量或函数的存储周期和作用域。

**修饰局部变量**
可以将局部变量的生命周期延长到整个程序的运行期间

**修饰全局变量/函数**
将其作用域限制在当前源文件（.cpp）内，使其成为内部链接，避免在多文件中重名冲突。
注意const也有这个作用

**修饰类成员变量（静态成员变量）**
这个变量属于整个类，而不是某个特定的对象，所有对象共享这一个变量。它必须在类外进行初始化。
```C++
   class User {
   public:
      static int user_count; // 声明
      User() { user_count++; }
   };

   int User::user_count = 0; // 在类外定义和初始化

   // User u1, u2; 之后，User::user_count 的值会是 2
```

**3、引用**

经典的面试题，从区别上来回答：

| 特性 | 指针 (Pointer) | 引用 (Reference) |
| :--- | :--- | :--- |
| **空值** | 可以是 `nullptr` | **必须**引用一个已存在的对象，不能为空 |
| **初始化** | 可以不初始化（成为野指针） | **必须**在声明时就初始化 |
| **可变性** | 可以改变指向，指向另一个对象 | 一旦绑定一个对象，就**不能**再改变为另一个对象的引用 |
| **本质** | 存储的是一个内存地址 | 是一个对象的“别名”，在底层常由指针实现 |

## 二、面向对象
### 1、多态
多态的一个主要作用就是，可以让我们将派生类可以当做基类来统一处理

三个条件：
1. 继承：存在共有继承
2. 虚函数：基类函数通过virtua修饰，子类通过override
3. 基类指针和应用：使用时

 **底层实现原理：虚函数表**
> 可以看这个链接：[虚函数表](https://zhuanlan.zhihu.com/p/75172640)

多态的内部机制就是通过虚函数表来完成的。每个声明或继承了虚函数的类，都会维护一个自己专属的虚函数表。

这个表本质上是一个函数指针数组，它的每个元素都是一个指向虚函数的指针，而不会指向普通的成员函数。

当我们创建一个派生类的对象，并用一个基类的指针指向它时（例如 Base* ptr = new Derived();），在这个派生类对象的内存布局中，其虚函数指针（vptr）就会指向派生类自己的虚函数表。这样，当我们通过这个基类指针调用虚函数时（例如 ptr->virtual_func();），程序就能在运行时找到并执行派生类中重写的版本。

**总结：**

封装、继承、多态是面向对象设计的三个特征，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。

### 2、虚析构函数

虚析构函数 (Virtual Destructor)
这个问题我们之前在复习多态时已经详细讨论过，这里再次强调结论：

问题：通过一个基类指针 delete 一个派生类对象时，如果基类的析构函数不是虚函数，那么只有基类的析构函数会被调用，派生类的析构函数会被忽略，从而导致派生类部分的资源发生泄漏。

解决方案：将基类的析构函数声明为 virtual。

```C++

class Base {
public:
    virtual ~Base() {} // 关键！
};

```
原理：delete 操作会通过虚函数表机制，正确地找到并调用派生类的析构函数，而派生类的析构函数会自动调用其基类的析构函数，形成一个“析构链”，确保对象被完整、干净地销毁。

