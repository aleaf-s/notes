---
layout: post
title: "C++"
date: 2025-09-17
category: 秋招
---
**目录**
- [一、基础知识](#一基础知识)
- [二、面向对象](#二面向对象)
  - [1、多态](#1多态)
  - [2、虚析构函数](#2虚析构函数)
- [三、Modern C++](#三modern-c)
    - [1. 智能指针](#1-智能指针)
    - [2. 右值引用](#2-右值引用)
    - [3. Lambda 表达式](#3-lambda-表达式)
  - [4. 其他](#4-其他)
- [四、STL](#四stl)
    - [1. 容器 (Containers)](#1-容器-containers)
    - [2. Algorithms](#2-algorithms)
    - [3. 迭代器](#3-迭代器)

> 主要搜集自AI+ 各种秋招友分享的面试题

## 一、基础知识
**1、 const关键字**

这个修饰符是为了告诉编译器修饰的东西是**只读**的

**修饰变量**
表示定义后就不能修改了！

**修饰指针**
这个需要稍微记一下是修饰的指针还是指向的内容
``` cpp
   // 常量指针
   int a = 10;
   int b = 20;
   const int* p1 = &a; 
   // *p1 = 5;      // 错误！不能通过p1修改a的值
   p1 = &b;       // 正确！p1可以指向其他地方
```

``` cpp
   // 指针常量
   int a = 10;
   int b = 20;
   int* const p2 = &a;
   *p2 = 5;       // 正确！可以通过p2修改a的值
   // p2 = &b;      // 错误！p2不能再指向b
```

**修饰成员函数**
放在成员函数括号后面，表示这个函数不会修改类的任何成员变量
> 注意他的一个内部机制是修饰的 this 指针，所以就导致了传进来的所有成员函数都是const

```cpp
   class MyClass {
      int value;
   public:
      int getValue() const { // 常成员函数
         // value = 10; // 错误！不能修改成员变量
         return value;
      }
   };
```

**2、static**
static 关键字用于改变变量或函数的存储周期和作用域。

**修饰局部变量**
可以将局部变量的生命周期延长到整个程序的运行期间

**修饰全局变量/函数**
将其作用域限制在当前源文件（.cpp）内，使其成为内部链接，避免在多文件中重名冲突。
注意const也有这个作用

**修饰类成员变量（静态成员变量）**
这个变量属于整个类，而不是某个特定的对象，所有对象共享这一个变量。它必须在类外进行初始化。
```cpp
   class User {
   public:
      static int user_count; // 声明
      User() { user_count++; }
   };

   int User::user_count = 0; // 在类外定义和初始化

   // User u1, u2; 之后，User::user_count 的值会是 2
```

**3、引用**

经典的面试题，从区别上来回答：

| 特性 | 指针 (Pointer) | 引用 (Reference) |
| :--- | :--- | :--- |
| **空值** | 可以是 `nullptr` | **必须**引用一个已存在的对象，不能为空 |
| **初始化** | 可以不初始化（成为野指针） | **必须**在声明时就初始化 |
| **可变性** | 可以改变指向，指向另一个对象 | 一旦绑定一个对象，就**不能**再改变为另一个对象的引用 |
| **本质** | 存储的是一个内存地址 | 是一个对象的“别名”，在底层常由指针实现 |

**堆和栈的区别**

管理方式：

栈 (Stack)：是由编译器自动管理的。它主要存放函数的局部变量和参数，函数调用时自动分配，函数返回时自动释放。

堆 (Heap)：是由程序员手动管理的。我们通过new（C++）或malloc（C）来申请，必须手动delete或free来释放。

效率和大小：

栈：分配和回收非常快（只是移动栈顶指针），但空间小（通常只有几MB），如果分配过多，会导致栈溢出。

堆：分配和回收相对较慢（需要复杂的算法查找空闲块），但空间非常大，可以动态地申请大块内存。

生命周期和风险：

栈：变量的生命周期和它的作用域绑定，函数一结束，内存就没了。

堆：对象的生命周期从new开始，直到我们手动delete。如果忘记delete，就会导致内存泄漏 。

## 二、面向对象
### 1、多态
多态的一个主要作用就是，可以让我们将派生类可以当做基类来统一处理

三个条件：
1. 继承：存在共有继承
2. 虚函数：基类函数通过virtual修饰，子类通过override
3. 基类指针和应用：使用时

 **底层实现原理：虚函数表**
> 可以看这个链接：[虚函数表](https://zhuanlan.zhihu.com/p/75172640)

多态的内部机制就是通过虚函数表来完成的。每个声明或继承了虚函数的类，都会维护一个自己专属的虚函数表。

这个表本质上是一个函数指针数组，它的每个元素都是一个指向虚函数的指针，而不会指向普通的成员函数。

当我们创建一个派生类的对象，并用一个基类的指针指向它时（例如 Base* ptr = new Derived();），在这个派生类对象的内存布局中，其虚函数指针（vptr）就会指向派生类自己的虚函数表。这样，当我们通过这个基类指针调用虚函数时（例如 ptr->virtual_func();），程序就能在运行时找到并执行派生类中重写的版本。



**总结：**

封装、继承、多态是面向对象设计的三个特征，而多态可以说是面向对象设计的关键。C++通过虚函数表，实现了虚函数与对象的动态绑定，从而构建了C++面向对象程序设计的基石。

### 2、虚析构函数

虚析构函数 (Virtual Destructor)
这个问题我们之前在复习多态时已经详细讨论过，这里再次强调结论：

问题：通过一个基类指针 delete 一个派生类对象时，如果基类的析构函数不是虚函数，那么只有基类的析构函数会被调用，派生类的析构函数会被忽略，从而导致派生类部分的资源发生泄漏。

解决方案：将基类的析构函数声明为 virtual。

```cpp

class Base {
public:
    virtual ~Base() {} // 关键！
};

```
原理：delete 操作会通过虚函数表机制，正确地找到并调用派生类的析构函数，而派生类的析构函数会自动调用其基类的析构函数，形成一个“析构链”，确保对象被完整、干净地销毁。

## 三、Modern C++


#### 1. 智能指针

  * **`std::unique_ptr` (独占型智能指针)**

      * **核心思想**：**独占**所指向的资源。同一时间内，只有一个 `unique_ptr` 可以指向一个给定的对象。
      * **特性**：**禁止拷贝**，但**可以移动 (move)**。这意味着你不能`unique_ptr p2 = p1;`，但可以把所有权从一个函数转移到另一个函数。

  * **`std::shared_ptr` (共享型智能指针)**

      * **核心思想**：允许多个 `shared_ptr` **共享**同一个资源的所有权。
      * **实现原理**：内部使用**引用计数 (Reference Counting)**。每当有一个新的 `shared_ptr` 指向该资源，引用计数就+1；每当有一个 `shared_ptr` 被销毁（或指向别处），引用计数就-1。当引用计数变为0时，资源被自动释放。
      * **应用场景**：当你需要将一个资源的所有权交由多个独立的模块或对象共同管理时使用。例如，多个对象都需要访问同一个配置信息对象。

  * **`std::weak_ptr` (弱引用指针)**

      * **核心思想**：它是一个**观察者**，可以指向 `shared_ptr` 管理的资源，但**不增加引用计数**。它本身不持有资源的所有权。
      * **作用**：为了解决 `shared_ptr` 可能导致的**循环引用 (Cyclic Dependency)** 问题。
          * **循环引用**：如果对象A的 `shared_ptr` 指向对象B，同时对象B的 `shared_ptr` 又指向对象A，那么它们的引用计数永远不会变为0，导致两个对象都无法被释放，从而造成内存泄漏。
          * **解决方案**：将其中一方的 `shared_ptr` 改为 `weak_ptr`，打破循环。
      * **使用**：`weak_ptr` 不能直接访问对象，必须先通过 `lock()` 方法转换成一个有效的 `shared_ptr`。

#### 2. 右值引用

这是 C++11 中一个提升性能的革命性特性。

  * **要解决的问题**：在旧 C++ 中，对于临时对象（比如函数返回值）的拷贝，会产生大量的深拷贝开销，这些拷贝其实是不必要的。
  * **核心思想**：与其“拷贝”一个临时对象的内容，不如直接“**窃取**”它的资源。
  * **右值引用**：一种新的引用类型，专门用来绑定到即将销毁的**临时对象（右值）**。
  * **移动构造函数 / 移动赋值运算符**：这些是新的类成员函数，它们接受一个右值引用作为参数。在函数体内，它们不会去深拷贝资源，而是直接将源对象的指针等资源“窃取”过来，然后将源对象置为一个“空壳”状态。
  * **`std::move`**：一个函数模板，它的作用是**无条件地将一个左值强制转换为右值**，使得我们可以对这个左值调用移动构造函数。它本身并不移动任何东西，只是一个“类型转换器”。

#### 3. Lambda 表达式

一种在代码中就地创建**匿名函数对象**的简洁语法。它极大地简化了代码，尤其是在与STL算法配合使用时。

**基本语法**：`[捕获列表](参数列表) -> 返回类型 { 函数体 }`

  * **捕获列表 `[]`**：是Lambda的精髓，用于从外部作用域“捕获”变量。
      * `[]`：不捕获任何变量。
      * `[=]`：以**值拷贝**的方式捕获所有外部变量。
      * `[&]`：以**引用**的方式捕获所有外部变量。
      * `[x, &y]`：以值方式捕获x，以引用方式捕获y。

**【代码示例】**
``` cpp
#include <vector>
#include <algorithm>
#include <iostream>

std::vector<int> numbers = {1, 2, 3, 4, 5, 6};
int threshold = 3;

// 使用Lambda表达式，找出所有大于threshold的数
auto it = std::find_if(numbers.begin(), numbers.end(), 
    [threshold](int n) { // 按值捕获threshold
        return n > threshold;
    }
);

if (it != numbers.end()) {
    std::cout << "First number greater than " << threshold << " is " << *it << std::endl;
}
```

### 4. 其他

  * **`auto` 关键字**：让编译器自动推导变量类型，简化代码。
  * **`nullptr`**：类型安全的空指针，用于替代宏 `NULL`。
  * **范围 for 循环 (Range-based for loop)**：更简洁地遍历容器。

```cpp
for (int num : numbers) {
    std::cout << num << std::endl;
}
```

  * **`override` 和 `final`**：`override` 确保派生类函数确实重写了基类的虚函数，`final` 阻止类被继承或函数被重写。

## 四、STL

STL主要由三驾马车组成：**Containers**、**Algorithms**、**Iterators**。

#### 1. 容器 (Containers)

**a) 序列式容器 (Sequence Containers)** - 元素按顺序排列

* **`std::vector`（动态数组）**  **（重点）**
    * **底层**：在堆上开辟一块连续内存。
    * **内部实现**：三个指针（_start, _finish, _end_of_storage）管理一块堆上的连续内存。
    * **size vs capacity**：size是已用空间，capacity是总分配空间。
    * **push_back 复杂度**：均摊 O(1)。
    * **扩容策略**：**2倍（或1.5倍）**指数增长，这是保证均摊O(1)复杂度的关键。
    * **现代C++优化**：扩容时优先使用移动语义 (Move Semantics) 来提升效率，并考虑异常安全。
    
    * **优点**：
        * **随机访问最快**（`O(1)`），因为内存连续，可以通过下标直接定位。
        * **缓存友好**（Cache Friendly），因为连续内存的局部性原理，遍历速度通常最快。
    * **缺点**：
        * 在**中间或开头插入/删除元素很慢**（`O(n)`），因为需要移动之后的所有元素。
        * 尾部插入 `push_back` 平均是 `O(1)`，但当容量不足需要**扩容**时，会触发一次 `O(n)` 的操作（申请新内存、拷贝旧元素、释放旧内存）。
    * **一句话总结**：**需要快速随机访问，且主要在尾部操作时，它是你的默认首选。**

* **`std::list`（双向链表）**
    * **底层**：**双向链表**，每个元素都存储着指向前一个和后一个元素的指针。
    * **优点**：
        * 在**任何位置插入/删除元素都非常快**（`O(1)`），只需要修改相邻元素的指针即可。
    * **缺点**：
        * **不支持随机访问**（访问第n个元素需要遍历，是 `O(n)`）。
        * **缓存不友好**，因为元素在内存中是散乱分布的，遍历性能不如`vector`。
    * **一句话总结**：**需要频繁在任意位置插入和删除，并且不关心随机访问时使用。**

* **`std::deque`（双端队列）**
    * **底层**：**分段的连续内存**，像是由多个小数组（内存块）组成的链表。
    * **优点**：
        * 支持**快速的随机访问**（`O(1)`，但比`vector`慢一个常数时间）。
        * 在**头部和尾部插入/删除都很快**（平均 `O(1)`）。
    * **缺点**：比`vector`结构更复杂，内存占用略高。
    * **一句话总结**：**当需要一个既有`vector`的快速访问，又有`list`两端快速操作的“混合体”时使用。**

**b) 关联式容器** - 元素根据键值自动排序

* **`std::map`（红黑树）**
    * **底层**：**红黑树**（一种自平衡二叉搜索树）。
    * **优点**：
        * 所有元素根据键（key）自动**排序**。
        * 所有操作（插入、删除、查找）的时间复杂度都稳定在**对数级别 `O(log n)`**。
    * **缺点**：空间开销比哈希表大，平均速度不如哈希表。
    * **一句话总结**：**需要存储键值对，并且对键的顺序有要求时使用。**

* **`std::set`**：和`map`类似，底层也是红黑树，但只存储键（key），没有值（value）。用于需要自动排序和去重的场景。

**c) 无序关联式容器 - C++11 引入**

* **`std::unordered_map`（哈希表）**
    * **底层**：**哈希表**。
    * **优点**：
        * 在没有哈希冲突的理想情况下，所有操作（插入、删除、查找）的平均时间复杂度都是**常数级别 `O(1)`**。
    * **缺点**：
        * **不排序**！元素的存储是无序的。
        * 最坏情况下的时间复杂度是 `O(n)`（当所有元素都哈希到同一个桶里时）。
        * 空间开销和对哈希函数的依赖较大。
    * **一句话总结**：**需要存储键值对，追求极致的查找效率，且不关心元素顺序时的默认首选。**

#### 2. Algorithms


* **`std::sort`**: 排序。只能用于支持随机访问迭代器的容器（如 `vector`, `deque`）。
* **`std::find` / `std::find_if`**: 查找元素。
* **`std::for_each`**: 对容器中每个元素执行一个操作。
* **`std::copy`**: 复制元素。

#### 3. 迭代器

迭代器是连接容器和算法的“胶水”，可以理解为一种泛化的指针。面试中一般不会深究，但需要知道：`vector` 的迭代器是随机访问迭代器，而 `list` 的是双向迭代器，这就是为什么`sort`不能用于`list`的原因（`sort`需要快速前后跳跃比较元素）。
