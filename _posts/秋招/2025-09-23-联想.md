---
layout: post
title: "联想"
date: 2025-09-23
category: 秋招
---

**目录**
- [笔试](#笔试)



## 笔试

选择题20道，内容范围挺广的：操作系统+数据结构+计算机网络+数据库+安卓开发+linux开发+算法+高级语言特征

代码题：难度中等吧，两道题就做出来一道，第二题回溯感觉有点难

**第一题**：输入一个由R和B组成字符串，然后一直重复该字符串，请你统计边界在[left,right] 范围内的字符B的数量

考察：前缀和。   直接for循环遍历会超时

代码：
```cpp

#include <iostream>
#include <string>
#include <vector>

using namespace std;

int countPre(const vector<int>& dp, int idx){
    // BRB BRB      idx = 3  
    int dp_len = dp.size();

    int n = idx/dp_len;

    int right = idx%dp_len;

    int res = 0;
    if(right>0){
        res = n*dp[dp_len-1] + dp[right-1];
    }else{
        res =  n*dp[dp_len-1];
    }
    
    return res;
}

int main() {
    string s;
    getline(cin, s);
    int left, right;
    
    cin >> left >> right;
    vector<int> dp(s.size());

    
    for(int i = 0; i< s.size(); ++i){
        if(i==0){
            dp[i] = s[i]=='B'? 1 : 0;
            continue;
        }
        dp[i] = s[i]=='B'? dp[i-1]+1 : dp[i-1];
    }
    // 计算最终结果
    int result = countPre(dp, right) - countPre(dp,left-1);

    // 输出
    std::cout << result << std::endl;
    return 0;
}

```

**第二题**：你将得到一个整数数组 matchsticks ，其中 matchsticks[i] 是第 i 个火柴棒的长度。你要用 所有的火柴棍 拼成一个正方形。你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次 。

如果你能使这个正方形，则返回 true ，否则返回 false 。

考察：回溯+剪枝。 比常规回溯难没做出来

```cpp

#include <vector>
#include <numeric>   // for std::accumulate
#include <algorithm> // for std::sort
#include <functional> // for std::greater

class Solution {
public:
    bool makesquare(std::vector<int>& matchsticks) {
        // 1. 前期可行性判断
        long long sum = std::accumulate(matchsticks.begin(), matchsticks.end(), 0LL);
        if (sum % 4 != 0) {
            return false;
        }
        int side_len = sum / 4;

        // 2. 排序优化
        // std::greater<int>() 表示从大到小排序
        std::sort(matchsticks.begin(), matchsticks.end(), std::greater<int>());
        
        // 检查是否有火柴长度大于边长
        if (matchsticks[0] > side_len) {
            return false;
        }
        
        // sides数组记录4条边的当前长度
        std::vector<int> sides(4, 0);
        
        return dfs(0, matchsticks, sides, side_len);
    }

private:
    // index: 当前处理的火柴索引
    // sides: 4条边的长度
    // target: 目标边长
    bool dfs(int index, const std::vector<int>& matchsticks, std::vector<int>& sides, int target) {
        // 递归终止条件（成功）
        if (index == matchsticks.size()) {
            return true;
        }

        // 尝试将当前火柴放入4条边中的一条
        for (int i = 0; i < 4; ++i) {
            // 剪枝：如果放入后超过目标长度，则跳过
            if (sides[i] + matchsticks[index] > target) {
                continue;
            }
            // 剪枝：如果当前边和前一条边长度一样，说明是重复状态，跳过
            if (i > 0 && sides[i] == sides[i - 1]) {
                continue;
            }

            // 做选择
            sides[i] += matchsticks[index];
            
            // 继续递归
            if (dfs(index + 1, matchsticks, sides, target)) {
                return true;
            }
            
            // 撤销选择（回溯）
            sides[i] -= matchsticks[index];
        }

        // 递归终止条件（失败）
        return false;
    }
};

```
