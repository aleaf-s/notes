---
layout: post
title: "计算机网络"
date: 2025-09-21
category: 计算机基础
---

**目录**
- [第一部分：宏观蓝图 —— 网络分层模型 (OSI 和 TCP/IP)](#第一部分宏观蓝图--网络分层模型-osi-和-tcpip)
  - [笔试重点 1：OSI七层模型 (理论模型)](#笔试重点-1osi七层模型-理论模型)
  - [笔试重点 2：TCP/IP四层/五层模型 (事实标准)](#笔试重点-2tcpip四层五层模型-事实标准)
- [第二部分：应用层 —— 网页浏览的基石 (HTTP协议)](#第二部分应用层--网页浏览的基石-http协议)
  - [什么是HTTP？](#什么是http)
  - [笔试重点 1：GET 和 POST 的区别 (必考)](#笔试重点-1get-和-post-的区别-必考)
  - [笔试重点 2：常见的HTTP状态码 (必考)](#笔试重点-2常见的http状态码-必考)
- [第三部分：应用层进阶 —— 安全的HTTP (HTTPS)](#第三部分应用层进阶--安全的http-https)
  - [笔试重点 1：HTTPS解决了哪三大安全问题？(必考)](#笔试重点-1https解决了哪三大安全问题必考)
  - [笔试重点 2：HTTPS的“握手”过程 (简化理解)](#笔试重点-2https的握手过程-简化理解)
  - [笔试重点 3：HTTP和HTTPS的区别总结](#笔试重点-3http和https的区别总结)
- [第四部分：传输层核心 (上) —— TCP三次握手详解](#第四部分传输层核心-上--tcp三次握手详解)
  - [一、 握手前的准备：认识几个“暗号”](#一-握手前的准备认识几个暗号)
  - [二、 三次握手的详细步骤](#二-三次握手的详细步骤)
  - [三、 笔试核心追问：为什么必须是三次，两次不行吗？](#三-笔试核心追问为什么必须是三次两次不行吗)
- [第五部分：传输层核心 (下) —— TCP四次挥手详解](#第五部分传输层核心-下--tcp四次挥手详解)
  - [一、 为什么要四次挥手？](#一-为什么要四次挥手)
  - [二、 四次挥手的详细步骤](#二-四次挥手的详细步骤)
  - [笔试核心追问 1：为什么是四次，而不是像握手一样三次？](#笔试核心追问-1为什么是四次而不是像握手一样三次)
  - [笔试核心追問 2：为什么客户端最后要进入 TIME\_WAIT 状态等待 2MSL？](#笔试核心追問-2为什么客户端最后要进入-time_wait-状态等待-2msl)
- [第六部分：传输层终章 —— UDP协议与TCP/UDP对比](#第六部分传输层终章--udp协议与tcpudp对比)
  - [一、 什么是UDP？](#一-什么是udp)
  - [二、 笔试核心：UDP的特点](#二-笔试核心udp的特点)
  - [三、 笔试核心：什么时候使用UDP？](#三-笔试核心什么时候使用udp)
  - [四、 终极总结：TCP vs. UDP 对比 (必考)](#四-终极总结tcp-vs-udp-对比-必考)



我们就从第一个、也是最重要、最宏观的概念开始：**网络为什么要分层？**

---

### 第一部分：宏观蓝图 —— 网络分层模型 (OSI 和 TCP/IP)

想象一个复杂的问题：你要从东京给一个在北京的朋友写一封信，而且信的内容需要保密。

如果你一个人来处理所有事情，会非常复杂：
1.  你要用中文写信。
2.  为了保密，你要用一种双方都懂的密码来加密。
3.  你要把信装进信封，写上地址。
4.  你要查清楚这封信该走空运还是海运，经过哪些中转站。
5.  你要把信送到本地邮局的正确柜台。
6.  邮局要把它装上正确的邮车...
...一直到你朋友收到信，反向做所有事情。

这个过程太复杂了！所以现实中，邮政系统把它“分层”了：
* **你 (用户)**：只管写信 (内容)。
* **翻译/加密员**：只管把信的内容转换成密文。
* **办公室秘书**：只管把信装进信封，写上地址。
* **物流调度中心**：只管规划最佳运输路径（走空运，从东京->上海->北京）。
* **快递员**：只管把信件从一个点送到下一个点（比如从办公室送到机场）。
* **司机/飞行员**：只管开车/开飞机，把货物运到目的地。

每一层的人都只关心自己的工作，并和上下层的人打交道。这就是**分层**思想，它**将一个复杂的问题，拆解成一堆更小、更简单、更容易管理的问题**。

计算机网络也是用完全相同的思想来设计的。

#### 笔试重点 1：OSI七层模型 (理论模型)

为了让全世界的电脑都能互相通信，国际标准组织(ISO)提出了一个理论上的网络模型，叫做 **OSI (Open Systems Interconnection) 模型**。它像一个完美的“网络通信蓝图”，把网络通信分成了7个层次。

**你不需要记住每一层的全部细节，但你需要记住这七层的名字、顺序和大致功能。**

从上到下（从离用户最近到离物理网线最近）：

* **第7层：应用层 (Application Layer)**
    * **功能**：为应用程序提供网络服务。你每天接触的App都在这一层。
    * **例子**：HTTP (浏览网页), FTP (文件传输), SMTP (发邮件), **DNS**。

* **第6层：表示层 (Presentation Layer)**
    * **功能**：数据的格式化、加密/解密、压缩/解压。确保一个系统应用层发出的信息可以被另一个系统应用层读取。
    * **例子**：JPEG, GIF图片格式, SSL/TLS加密。

* **第5层：会话层 (Session Layer)**
    * **功能**：建立、管理和终止两个通信主机之间的“会话”或连接。

* **第4层：传输层 (Transport Layer)**
    * **功能**：负责**端到端**的、可靠或不可靠的数据传输。
    * **核心协议**：**TCP** 和 **UDP**。

* **第3层：网络层 (Network Layer)**
    * **功能**：负责将数据包从源头送到最终目的地（逻辑地址寻址和路由选择）。
    * **核心协议**：**IP协议** (我们天天说的IP地址就在这一层)。

* **第2层：数据链路层 (Data Link Layer)**
    * **功能**：负责在**相邻**的两个节点之间传输数据帧（物理地址寻址）。
    * **核心概念**：**MAC地址** (网卡地址)。

* **第1层：物理层 (Physical Layer)**
    * **功能**：负责传输最原始的二进制比特流 (0和1)。
    * **例子**：网线、光纤、无线电波。

#### 笔试重点 2：TCP/IP四层/五层模型 (事实标准)

OSI模型只是一个理论上的“完美蓝图”，但在现实世界中，互联网实际运行的是一个更简洁、更实用的模型，叫做 **TCP/IP模型**。

它把OSI模型中一些功能类似的层合并了：

| OSI模型             | TCP/IP模型        |
| ------------------- | ----------------- |
| **应用层** |                   |
| **表示层** | **应用层** |
| **会话层** |                   |
| **传输层** | **传输层** |
| **网络层** | **网络层 (或网际层)** |
| **数据链路层** | **网络接口层** |
| **物理层** |                   |

**敲黑板**：在笔试和面试中，面试官可能嘴上问的是OSI七层（因为它是理论基础），但心里想的、实际考察的协议和技术，几乎都是TCP/IP模型里的东西。所以你两个都要知道，但**重点要放在TCP/IP模型涉及的协议上**。

---

**第一部分总结与提问：**

我们今天的第一个知识点就是：
1.  计算机网络为了解决复杂性，采用了**分层**的设计思想。
2.  **OSI七层模型**是国际标准的理论框架，你需要知道每一层的名字和大概功能。
3.  **TCP/IP模型**是互联网实际使用的标准，是我们将要学习的重点。

### 第二部分：应用层 —— 网页浏览的基石 (HTTP协议)

应用层决定了应用程序之间如何沟通。当你用浏览器上网、用QQ聊天、用网易云音乐听歌时，你都在使用应用层的协议。

在所有应用层协议中，笔试考得最多的，毫无疑问是 **HTTP (HyperText Transfer Protocol)，超文本传输协议**。

#### 什么是HTTP？

简单说，**HTTP就是你的浏览器和网站服务器之间沟通时使用的“语言”**。

它是一种**请求-响应**模型：
1.  **请求 (Request)**: 你的浏览器（客户端）向网站服务器发送一个请求，说：“你好，我想看看你主页上的内容”。
2.  **响应 (Response)**: 网站服务器收到请求后，会回复一个响应，说：“好的，这是你要的主页内容（HTML代码）”，然后把内容发给你。

HTTP本身是一个“无状态”(Stateless)的协议。这意味着服务器不会记住你之前做过什么。你第一次请求和他第一万次请求，对他来说都是一个全新的请求。这就像一个记性很差的客服，每次你打电话过去都要重新介绍一遍你是谁。 (为了解决这个问题，后来发明了Cookie和Session技术，我们以后可以讲)。

#### 笔试重点 1：GET 和 POST 的区别 (必考)

浏览器向服务器发请求时，可以用不同的“方法”(Method)。最常见的两种就是GET和POST。面试官特别喜欢问它们的区别。

| 特性     | GET                                                   | POST                                                    |
| :------- | :---------------------------------------------------- | :------------------------------------------------------ |
| **作用** | 从服务器**获取**数据 (比如看新闻、刷网页)             | 向服务器**提交**数据 (比如登录、发帖子、上传文件)       |
| **数据位置** | 参数数据放在 **URL** 的后面，用 `?` 连接 (比如 `.../login?user=Tom&pwd=123`) | 参数数据放在**请求体 (Request Body)** 里面                  |
| **安全性** | **不安全**。因为数据在URL里，会显示在地址栏，还会被浏览器历史记录保存。 | **相对安全**。因为数据在请求体里，不会显示在地址栏，也不会被缓存。 |
| **数据大小** | **有大小限制**。因为URL长度有限制。                   | **没有大小限制**。可以提交大量数据。                      |
| **缓存** | 请求可以被缓存。                                      | 请求默认不被缓存。                                      |

**记忆技巧**：
* **GET** 就像是**明信片**：地址和内容都写在外面，所有人都能看到，而且能写的内容有限。
* **POST** 就像是**快递包裹**：地址写在外面，但具体的东西（数据）是封装在里面的，更安全，也能装更多东西。

#### 笔试重点 2：常见的HTTP状态码 (必考)

服务器在回复浏览器时，会附带一个三位数的“状态码”，告诉浏览器这次请求的结果是怎样的。你需要记住几个最常见的：

* **2xx (成功)**
    * `200 OK`: 请求成功。这是最常见的状态码。

* **3xx (重定向)**
    * `301 Moved Permanently`: 永久重定向。你请求的资源已经永久搬家了，以后请访问新地址。
    * `302 Found`: 临时重定向。资源只是临时搬家，下次还请访问老地址。

* **4xx (客户端错误)**
    * `400 Bad Request`: 请求本身有语法错误，服务器看不懂。
    * `403 Forbidden`: 服务器理解了你的请求，但是**拒绝**执行。你没有权限访问。
    * `404 Not Found`: **最经典的错误**。服务器上找不到你请求的资源（网页、图片等）。

* **5xx (服务器端错误)**
    * `500 Internal Server Error`: 服务器内部出了问题，不知道咋办了。
    * `503 Service Unavailable`: 服务器当前正忙或者正在维护，暂时无法处理请求。

**记忆技巧**：
* **2开头** = 一切顺利，成功了！
* **3开头** = 需要绕路，它搬家了。
* **4开头** = **你**（客户端）犯错了。
* **5开头** = **我**（服务器）犯错了。

---

**第二部分总结与提问：**

我们学习了应用层最重要的协议HTTP：
1.  它是一个**请求-响应**模型，是浏览器和服务器沟通的语言。
2.  **GET**和**POST**是两种最常见的请求方法，它们的区别是高频考点。
3.  **HTTP状态码**是服务器对请求结果的反馈，你需要记住 `200, 301, 403, 404, 500` 这几个经典代码的含义。


### 第三部分：应用层进阶 —— 安全的HTTP (HTTPS)


刚才我们聊的HTTP，就像是在网络上用明信片通信，内容是完全暴露的。如果你在网上登录、支付，用HTTP就等于把你的密码和银行卡号写在明信片上，任何在中间环节（比如同一个WiFi下的黑客、网络运营商等）的人都能看到。这显然是无法接受的。

为了解决这个问题，HTTPS诞生了。

---

**HTTPS (HyperText Transfer Protocol Secure)** 的本质很简单：

**HTTPS = HTTP + SSL/TLS**

它就是在原本不安全的HTTP协议下面，加了一层叫做 **SSL/TLS** 的安全加密层。这层就像一个“安全管道”，所有HTTP数据都要先经过这个管道进行加密，然后再发送出去。

* **SSL (Secure Sockets Layer)**：安全套接层，是早期的版本。
* **TLS (Transport Layer Security)**：传输层安全协议，是SSL的升级版，现在用的基本都是TLS。

**比喻升级**：
* **HTTP** 是 **明信片**，内容公开。
* **HTTPS** 是用一个无法破解的**保险箱**来寄送明信片，只有拥有钥匙的你和收件人才能打开。

#### 笔试重点 1：HTTPS解决了哪三大安全问题？(必考)

HTTPS通过SSL/TLS层，主要提供了三大核心安全保障：

1.  **数据加密 (Data Encryption)**
    * **解决的问题**：防止数据在传输过程中被**窃听**。
    * **如何做到**：通过复杂的加密算法（对称加密和非对称加密结合），将你发送的所有内容（URL、请求头、请求体）都变成一堆乱码。就算黑客截获了数据，也看不懂是什么意思。

2.  **身份认证 (Identity Authentication)**
    * **解决的问题**：确认你正在访问的网站是**真的**，而不是一个冒牌的“钓鱼网站”。
    * **如何做到**：通过 **数字证书 (Digital Certificate)**。一个正规的网站会向一个权威的、受信任的第三方机构（叫做 **CA - Certificate Authority**）申请一个数字证书。这个证书就像是网站的“官方身份证”。当你的浏览器访问一个HTTPS网站时，会先检查这个网站的“身份证”是不是由权威机构颁发的、有没有过期、是不是颁发给这个域名的。如果验证通过，浏览器地址栏就会显示一把小锁，告诉你这个网站身份可信。

3.  **数据完整性 (Data Integrity)**
    * **解决的问题**：防止数据在传输过程中被**篡改**。
    * **如何做到**：通信双方会通过一种算法（消息认证码）来为传输的数据计算一个“指纹”。接收方收到数据后，会用同样的方法计算“指纹”，如果两个指纹对得上，就说明数据在路上没有被修改过。

#### 笔试重点 2：HTTPS的“握手”过程 (简化理解)

浏览器和服务器在开始用HTTPS加密通信前，需要一个“接头”的过程，这个过程叫做“**握手 (Handshake)**”。握手过程很复杂，但你只需要理解它的核心目的：**安全地商量出后续通信要用的“对称加密密钥”**。

大致流程如下：
1.  **客户端 -> 服务器**：你好，我想跟你安全通信！我支持这些加密算法。
2.  **服务器 -> 客户端**：你好！我们用这个加密算法吧。这是我的**数字证书（内含公钥）**，你验证一下我的身份。
3.  **客户端**：
    * 验证服务器的证书是真的。
    * 生成一个随机的**密钥**（这个就是之后真正用来加密HTTP数据的“对称密钥”）。
    * 用服务器证书里的**公钥**把这个随机密钥加密，然后发给服务器。
4.  **服务器**：
    * 用自己的**私钥**解开客户端发来的包裹，拿到了那个随机密钥。
5.  **握手结束**：现在，客户端和服务器都拥有了同一个、别人不知道的密钥。之后所有的HTTP通信，都用这个密钥进行加密和解密。

#### 笔试重点 3：HTTP和HTTPS的区别总结

| 特性     | HTTP                                     | HTTPS                                                          |
| :------- | :--------------------------------------- | :------------------------------------------------------------- |
| **安全性** | 明文传输，不安全                         | 使用SSL/TLS加密，非常安全                                      |
| **URL前缀**| `http://`                                | `https://`                                                     |
| **默认端口**| 80                                       | 443                                                            |
| **证书** | 不需要证书                               | 需要向CA申请数字证书                                           |
| **开销** | 无额外开销                               | 建立连接时有“握手”过程，会消耗更多服务器资源和少量时间         |

---

**第三部分总结与提问：**

我们学习了HTTP的安全版HTTPS：
1.  **HTTPS = HTTP + SSL/TLS**，它通过加密层解决了HTTP的裸奔问题。
2.  它主要提供了**数据加密、身份认证、数据完整性**三大安全保障。
3.  通过**数字证书**来验证服务器的身份，通过**握手**过程来安全地交换后续通信用的密钥。
4.  它和HTTP在**端口、URL、证书**等方面都有区别。


好的，当然可以。TCP的三次握手是网络协议中最重要的概念之一，几乎是所有网络相关岗位笔试和面试的必考题。我们把它彻底讲透。

---

### 第四部分：传输层核心 (上) —— TCP三次握手详解

我们已经知道，三次握手属于**TCP协议**，发生在**传输层**，目的是**建立一个可靠的连接**。

现在我们深入细节，看看这三次“握手”究竟传递了什么信息。

#### 一、 握手前的准备：认识几个“暗号”

在TCP数据包的头部，有几个重要的“标志位”（Flags），像开关一样，只有0和1两种状态。握手主要用到其中两个：

* **SYN (Synchronize Sequence Numbers)**:
    * 当 `SYN = 1` 时，表示这是一个“请求建立连接”或“同意建立连接”的报文。它的核心作用是用来**同步序列号**。

* **ACK (Acknowledgment)**:
    * 当 `ACK = 1` 时，表示这是一个“确认”报文，说明我收到了你发来的东西。

另外，还有两个关键的32位数字：

* **序列号 (Sequence Number, `seq`)**:
    * 就像我们之前比喻的“页码”。它告诉对方，我这次发的数据是从哪个“页码”开始的。

* **确认号 (Acknowledgment Number, `ack`)**:
    * 这个有点绕，但非常关键。它告诉对方，**我已经收到了你的数据，我期望你下一次从这个‘页码’开始发**。
    * 比如，如果我收到了你发来的 `seq=100` 的数据包，这个包有10个字节长。那么我会回复你 `ack=110`，意思是“你100到109的数据我都收到了，你下次从110开始发吧”。

好了，有了这些“暗号”的基础，我们来看三次握手的过程。

---

#### 二、 三次握手的详细步骤

我们假设客户端是你的电脑，服务器是百度的网站。

 **第一次握手 (Client -> Server)**

* **动作**: 客户端想和服务器建立连接，于是发送一个TCP报文。
* **报文内容**:
    * `SYN = 1` (告诉服务器：我想和你建立连接)
    * `ACK = 0` (因为是第一次打招呼，没什么需要确认的)
    * `seq = x` (客户端随机选择一个初始序列号x，比如 `x=1000`)
* **客户端状态**: 发送后，客户端进入 `SYN_SENT` (已发送SYN) 状态，等待服务器确认。
* **通俗比喻**: 你打电话给朋友，说：“**喂，我是小明，我想跟你说话，我的第一句话编号是1000。**”

 **第二次握手 (Server -> Client)**

* **动作**: 服务器收到了客户端的请求，如果同意建立连接，就会回复一个报文。
* **报文内容**: 这个报文同时做了两件事：**同意你的请求** + **我也提出我的请求**。
    * `SYN = 1` (告诉客户端：我也想和你建立连接)
    * `ACK = 1` (告诉客户端：我收到了你的请求)
    * `seq = y` (服务器也随机选择一个自己的初始序列号y，比如 `y=5000`)
    * `ack = x + 1` (告诉客户端：我收到了你的序列号x，期望你下一个发给我 `x+1` 的数据。在这里就是 `ack=1001`)
* **服务器状态**: 发送后，服务器进入 `SYN_RECEIVED` (已收到SYN) 状态。
* **通俗比喻**: 你的朋友听到了，回答说：“**好的小明，我听到了！(ACK=1)。我也想跟你说话，我的第一句话编号是5000 (SYN=1, seq=y)。另外，我确认收到了你编号1000的话，你下一句请从1001开始说 (ack=1001)。**”

 **第三次握手 (Client -> Server)**

* **动作**: 客户端收到了服务器的同意和请求，于是发送最后一个确认报文。
* **报文内容**:
    * `SYN = 0` (连接已经建立，不再需要请求了)
    * `ACK = 1` (告诉服务器：我收到了你的确认)
    * `seq = x + 1` (根据服务器的期望，我这次发送的序列号是 `x+1`，即 `seq=1001`)
    * `ack = y + 1` (告诉服务器：我收到了你的序列号y，期望你下一个发给我 `y+1` 的数据。在这里就是 `ack=5001`)
* **连接状态**: 发送后，客户端和服务器都进入 `ESTABLISHED` (已建立连接) 状态。此时，TCP连接正式建立，双方可以开始传输数据。
* **通俗比喻**: 你听到朋友的回答后，说：“**好的，我收到了你的确认和你的话的编号！(ACK=1)。现在我们可以正式聊天了。**”

---

#### 三、 笔试核心追问：为什么必须是三次，两次不行吗？

这是最经典的面试题。答案是：**不行，主要是为了防止“已失效的连接请求报文”突然又传送到了服务器，从而导致错误。**

想象一个场景：
1.  客户端发送了一个连接请求 `SYN(seq=x)`，但这个包在网络中被滞留了，没有马上到服务器。
2.  客户端等了半天没收到回复，以为丢了，于是又重新发送了一个新的连接请求 `SYN(seq=z)`。
3.  这次很顺利，服务器收到了新的请求，完成了“两次握手”（假设只需要两次），建立了连接，传输了数据，然后关闭了连接。
4.  **关键点来了**：这时，那个在网络中“迷路”很久的、**旧的** `SYN(seq=x)` 包，**终于抵达了服务器**！

**如果只有两次握手**：
* 服务器收到这个旧的SYN包，会以为是客户端又发起了一个新的连接请求。
* 于是服务器会回复一个 `SYN-ACK` 包，并**单方面地建立了一个新的连接**，然后傻傻地等待客户端发数据。
* 但此时的客户端根本不知道这件事，它不会理睬服务器的 `SYN-ACK`，更不会发数据。
* 结果就是，服务器白白地为这个“幽灵连接”浪费了资源，直到超时关闭。

**有了第三次握手**：
* 服务器收到旧的SYN包，回复 `SYN-ACK`。
* 客户端收到这个 `SYN-ACK` 后，会检查自己的状态。它发现自己当前并没有在请求建立连接，就知道这个 `SYN-ACK` 是个“历史遗留问题”。
* 于是客户端会发送一个 `RST` (Reset) 报文给服务器，告诉它“出错了，关闭连接”。
* 这样，服务器就不会傻傻地维持那个无效的连接了。

**总结**：第三次握手，是客户端对服务器请求的最终确认，它能确保双方都基于一个共同的、当前的意愿来建立连接，避免了历史遗留问题造成的混乱。

---

**第四部分总结与提问**

1.  三次握手是TCP协议建立连接的方式，发生在传输层。
2.  它通过交换`SYN`和`ACK`标志位以及`序列号(seq)`和`确认号(ack)`来完成。
3.  它的核心目标是**确保连接可靠**和**同步双方的初始序列号**，本身**不涉及加密**。
4.  必须是三次（而不是两次），主要是为了**防止已失效的历史连接请求对服务器造成干扰**。
   

好的，我们正式进入“第三章”的学习。

这一章我们将完成对**传输层**的探索，主要包含两个核心的笔试考点：TCP的“分手仪式”——**四次挥手**，以及TCP的“好兄弟”——**UDP协议**。

---

### 第五部分：传输层核心 (下) —— TCP四次挥手详解

既然有“三次握手”这样正式的“见面仪式”，那么TCP在断开连接时，也有一个同样严谨的“分手仪式”，这就是**四次挥手 (Four-way Wave)**。

#### 一、 为什么要四次挥手？

核心原因：**TCP是全双工通信，连接的断开需要双方都同意。**

* **打电话的比喻**：你和朋友打电话，你想挂了。你得先说：“喂，我没什么事了，准备挂了啊”。
* 这时，你的朋友可能会说：“好的，我知道了。**（这是第一次回应）**。哎，等一下，我再说最后一件事... **（对方可能还有话没说完）**”
* 等他把最后的事情说完，他会说：“好了，我也说完了，可以挂了。” **（这是第二次表态）**
* 最后你再说一句：“好的，拜拜”。然后双方才挂断。

你看，因为“你没话说”和“他没话说”是两个独立的事情，所以断开的过程需要你来我往好几步。

#### 二、 四次挥手的详细步骤

这次我们引入一个新的“暗号”标志位：
* **FIN (Finish)**: 当 `FIN = 1` 时，表示“我这边的数据已经全部发送完毕了，我请求断开连接”。

假设还是客户端（你的电脑）主动提出断开连接：

 **第一次挥手 (Client -> Server)**

* **动作**: 客户端决定关闭连接，向服务器发送一个TCP报文。
* **报文内容**: `FIN = 1`, `seq = u` (u是客户端上次发送数据的最后一个字节的序号+1)。
* **客户端状态**: 发送后，客户端进入 `FIN_WAIT_1` 状态。
* **通俗比喻**: 你说：“**我话说完了，准备挂了。**”

 **第二次挥手 (Server -> Client)**

* **动作**: 服务器收到了客户端的关闭请求。它先回复一个确认报文。
* **报文内容**: `ACK = 1`, `ack = u + 1`, `seq = v`。
* **服务器状态**: 发送后，服务器进入 `CLOSE_WAIT` (等待关闭) 状态。此时，服务器**还可以继续向客户端发送数据**（如果还有没发完的数据）。客户端收到后，进入 `FIN_WAIT_2` 状态，等待服务器也说“我说完了”。
* **通俗比喻**: 朋友说：“**好的，收到你要挂电话的请求了。但你等我一下，我还有几句话没说完。**”

 **第三次挥手 (Server -> Client)**

* **动作**: 服务器确认自己所有的数据也已经发送完毕，现在它可以正式关闭连接了。于是它再向客户端发送一个报文。
* **报文内容**: `FIN = 1`, `ACK = 1`, `ack = u + 1`, `seq = w` (w是服务器上次发送数据的最后一个字节的序号+1)。
* **服务器状态**: 发送后，服务器进入 `LAST_ACK` (最后确认) 状态，等待客户端的最终确认。
* **通俗比喻**: 朋友把话说完后，说：“**好了，我也说完了，现在可以挂了。**”

 **第四次挥手 (Client -> Server)**

* **动作**: 客户端收到了服务器的关闭请求，发送最后一个确认报文。
* **报文内容**: `ACK = 1`, `ack = w + 1`, `seq = u + 1`。
* **连接状态**:
    * 客户端发送后，进入 **`TIME_WAIT`** (时间等待) 状态。**这个状态非常重要，是笔试考点**。它会等待 `2MSL` (两倍报文最大生存时间) 后，才最终进入 `CLOSED` 状态。
    * 服务器收到这个确认后，立即进入 `CLOSED` 状态。连接正式断开。
* **通俗比喻**: 你说：“**好的，那挂了吧。**” (说完后你没有马上挂断，而是多等了一小会儿)。

#### 笔试核心追问 1：为什么是四次，而不是像握手一样三次？

因为服务器在收到客户端的 `FIN` 请求时（第一次挥手），可能自己还有数据没有发送完毕。所以它只能先回复一个 `ACK` (第二次挥手)，告诉客户端“我知道了”，但不能立刻发送自己的 `FIN`。只有当服务器自己的数据也全部发送完毕后，它才能发送 `FIN` (第三次挥手)。**这个ACK和FIN是分开发送的**，所以比三次握手多了一次。

#### 笔试核心追問 2：为什么客户端最后要进入 TIME_WAIT 状态等待 2MSL？

`MSL` 是报文在网络中最长可以存活的时间。等待 `2MSL` 的主要原因有两个：

1.  **确保服务器能收到最后的ACK**：客户端发送的最后一个ACK报文可能会丢失。如果丢失了，服务器就会因为收不到确认而重新发送第三次挥手的FIN报文。如果客户端发送ACK后立刻关闭，就收不到这个重发的FIN了，会导致服务器无法正常关闭。客户端等待 `2MSL` 就是为了确保，万一ACK丢了，自己也能收到服务器重发的FIN，并再次发送ACK。
2.  **防止“已失效的连接请求报文段”出现在本连接中**：等待 `2MSL` 可以确保本次连接中产生的所有报文都已经在网络中消失了，从而避免旧连接的“幽灵”数据包干扰到下一个使用相同端口的新连接。

---

**第五部分总结与提问：**

1.  TCP断开连接需要**四次挥手**，因为断开是双向的，而服务器在同意对方关闭请求和自己准备好关闭之间可能有一个时间差。
2.  核心过程是双方依次发送`FIN`和`ACK`。
3.  `TIME_WAIT`状态是客户端在最后等待的一个状态，目的是**保证连接的可靠关闭**和**防止旧连接的报文干扰新连接**。


### 第六部分：传输层终章 —— UDP协议与TCP/UDP对比
好的，我们已经深入了解了TCP这位认真负责的“电话客服”。现在，我们来认识一下它的同胞兄弟——UDP，它是一位追求极致速度的“快递闪送员”。

---


**UDP** 的全称是 **用户数据报协议 (User Datagram Protocol)**。

#### 一、 什么是UDP？

如果说TCP是“打电话”，那么UDP就是“**寄明信片**”。

* 你把明信片写好内容和地址，扔进邮筒，然后就**不再管它了**。
* 它**不保证**一定能送到。
* 它**不保证**按你寄的顺序送到。
* 它**不保证**中途内容不被损坏。
* 但它的优点是：**简单、快速、开销小**。

UDP就是这样一种“佛系”的协议，它提供的是一种**不可靠的、无连接的**通信服务，也被称为“尽力而为”(Best-Effort)的服务。

#### 二、 笔试核心：UDP的特点

UDP的特点几乎和TCP是完全相反的，对比记忆效果最好。

1.  **无连接 (Connectionless)**
    * 这是与TCP最根本的区别。UDP在发送数据前，**不需要**进行三次握手来建立连接。想发就发，直接把数据和目标地址扔给网络层。
    * **优点**：省去了建立和断开连接的开销，延迟低。

2.  **不可靠 (Unreliable)**
    * UDP不提供任何可靠性保障。它不关心数据包是否到达、是否按序、是否出错。
    * **注意**：这听起来是个缺点，但在某些场景下，这恰恰是它最大的优点。如果需要可靠，可以让上层的应用程序自己去实现。

3.  **面向报文 (Message-Oriented)**
    * 这与TCP的“字节流”不同。UDP把应用程序交下来的每一块数据都视为一个独立的“报文”(Datagram)，并原封不动地给它加上UDP头部后发送。它保留了应用程序发送时的数据边界。
    * **比喻**：TCP像水管里的水流，是连续的；UDP像一个个独立运输的集装箱，每个集装箱就是一个完整的单元。

4.  **头部开销小 (Small Header Overhead)**
    * UDP的头部非常简单，只有8个字节（而TCP头部至少20个字节）。这意味着协议本身占用的网络带宽更少，传输效率更高。

#### 三、 笔试核心：什么时候使用UDP？

既然UDP这么“不靠谱”，为什么我们还需要它？因为在很多场景下，**速度和实时性比可靠性更重要**。

1.  **实时通信**
    * **语音/视频通话 (VoIP)**, **在线直播**：在这种场景下，你能容忍偶尔画面卡一下或者声音断续（丢了几个包），但绝对无法忍受为了等一个丢失的包而导致整个画面长时间卡顿。最新的数据永远比旧的数据重要。
    * **在线游戏**：游戏中的位置、动作等信息要求极低的延迟。如果一个操作指令因为重传而晚到了一秒，那它就已经完全没用了。

2.  **查询响应速度要求高的场景**
    * **DNS查询**：我们之前讲过，DNS查询用的就是UDP。因为一次查询的数据量很小，用UDP速度飞快。如果查丢了怎么办？应用程序自己重新再查一次就行了，成本很低。如果用TCP，每次查询前都要三次握手，会大大增加延迟。

3.  **广播和多播**
    * 当需要把一个数据包同时发送给网络中的多个主机时（比如局域网内的服务发现），只能使用UDP。TCP的面向连接特性决定了它只能进行一对一的通信。

#### 四、 终极总结：TCP vs. UDP 对比 (必考)

这张表格请一定牢记，它是传输层知识点的精华总结。

| 对比维度 | TCP (传输控制协议) | UDP (用户数据报协议) |
| :--- | :--- | :--- |
| **通俗比喻** | 打电话 | 寄明信片 |
| **是否连接** | **面向连接** (三次握手，四次挥手) | **无连接** (想发就发) |
| **是否可靠** | **可靠** (确认、重传、有序) | **不可靠** (尽力而为) |
| **数据形式** | **字节流** (无边界，像水流) | **报文** (有边界，像集装箱) |
| **传输速率** | 慢 (开销大) | 快 (开销小) |
| **头部开销** | 大 (≥ 20字节) | 小 (8字节) |
| **核心机制** | 握手、挥手、ACK、重传、滑动窗口、拥塞控制 | 无 |
| **应用场景** | 网页(HTTP/S)、文件(FTP)、邮件(SMTP) | DNS、语音视频、在线游戏、直播 |

---

**第六部分总结与提问：**

我们认识了传输层的另一个协议UDP，并对比了它和TCP的区别：
1.  **UDP** 是一种**无连接、不可靠、面向报文**的协议，它的核心优势是**速度快、延迟低**。
2.  它适用于那些对**实时性要求高、能容忍少量丢包**的场景。
3.  TCP和UDP没有绝对的好坏之分，只有**适合与不适合**的场景，它们的区别是笔试的绝对重点。
